# 0 初衷

很多介绍红黑树的文章如同算法导论书中那样，都是上来直接给出一些分类情况，以及每个分类情况下的处理办法，而没有着重讲述为什么这么分类？为什么这个分类下执行这些操作？

这样可能就导致一种现象：我按照这些分类以及分类下的操作办法，的确完整的走通想通了整个算法过程，但是可能过了几个月后就忘记如何分类的了，忘记分类下如何操作的了。

归根到底是我们没有找出最本质的东西，比如说插入节点时遇到父子是红红的问题，对应的2个解决办法如下：

-	将父节点改成黑色，由于增加了黑色，所以必须在父节点的父节点减少黑色，

# 1 搜索

## 1.1 最大值

## 1.2 最小值和最大值

-	最小值：从根节点开始，不断的找左子树，直到遇见Nil
-	最大值：同理

## 1.3 前驱和后继

按照中序遍历的方式来给出指定节点的前驱和后继

-	后继

	如果该节点有右子树，则后继节点就是右子树的最小值
	如果没有右子树，则后继就是找到一个归属于左子树的父节点，该父节点就是后继

-	前驱

	同理

# 2 插入

也比较简单，就是对比找到一个节点，直到遇到null节点，则该null节点的父节点就是要插入节点的父节点

然后再判断要插入的节点是比父节点大还是小，大的话作为右节点，小的话作为左节点

# 3 删除

	二叉搜索树的中序遍历---》排好序的

	删除分成下面3种情况：

# 4 时间复杂度

只能说，如果高度是h，则时间复杂度是O(h),不能说N个节点的二叉搜索树的时间复杂度是O（logN）。因为二叉搜索树并不是平衡树，N个节点的高度可能为N

# 2 红黑树

## 2.1 红黑树的5个性质

-	1 每个节点或是红色，或是黑色
-	2 根节点是黑色
-	3 每个叶节点（NIL）是黑色
-	4 如果一个节点是红色，则它的2个子节点都是黑色
-	5 对于每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点

一颗红黑树示例如下：

![红黑树示例](https://static.oschina.net/uploads/img/201611/25102813_7cFi.png "红黑树示例")

可以得出的一些结论：

-	红黑树的任何一个节点的左右子树的高度最多是另一子树的2倍。

	由性质5和性质4可以得出，最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点，所以一个子树最多是另一个子树高的的2倍，就是所谓的近似平衡。

## 2.2 旋转

## 2.3 插入

## 2.3.1 普通插入

按照二叉搜索树的插入方式

## 2.3.2 插入后的修正

新插入的节点着色为红色，暂叫z节点，z的父节点叫z.p，它会违反红黑树的哪些性质？

-	违反性质2

	如果插入节点是根节点，则违反了性质2。此时只需要将z节点重新着为黑色即可。

-	违反性质4

	如果z.p是红色，那么就违反了性质4。下面就针对性质4来具体的分析怎么解决

目前要解决的问题是：z是红色，z.p也是红色

可以得到的一些结论：

-	z.p.p必然是黑色

	因为在z插入之前是一颗红黑树，必然要满足性质4，所以z.p.p是黑色，z的叔父节点是不确定的，可红可黑。

-	z的兄弟节点只能是叶节点（黑色的）

	z.p是红色的，则z的兄弟节点必须是黑色的，如果z的兄弟节点不是叶节点，则z的兄弟节点必然比z这一路多了一个黑色，不满足性质5，所以z的兄弟节点是黑色的叶节点。

解决问题的要领：

**不能增加或者减少黑高，只能部分增加并且部分减少然后相互抵消**

解决红红问题有2个思路：

-	1 **把z.p变成黑色，z.p.p变成红色**
-	2 **把z和z.p中的一个红色扔到z.p.p的另一个孩子中**

再来详细分析下这2个思路：

-	1 **把z.p由红色变成黑色，z.p.p由黑色变成红色**

	z这一路增加一个黑色，减少一个黑色，黑高不变。但是z的叔父那一路就会因为z.p.p而少了一个黑色，所以如果z的叔父是红色，那么可以将z的叔父由红色变成黑色来抵消z.p.p的减少。

	所以这个就要求z的叔父节点是红色。

	但是这并没有完，我们将z.p.p由黑色变成红色，可能又会出现红红的情况，所以继续下一次的轮回

-	2 **把z和z.p中的一个红色扔到z.p.p的另一个孩子中**

	这个扔的操作就是通过左旋或者右旋，目前假如是右旋，将z.p提升为z.p.p的位置，将z.p.p拉下来作为z的叔父节点的一路。颜色上，z.p由红变成黑色，z.p.p由黑色变成红色（这就要求z的叔父必须是黑色，不然又出现红红）。此时z和z的叔父2路都没有增加或者减少黑色。同时z.p的右子树会作为z.p.p的左子树（右旋的结果），此时z.p.p是红色，则z.p的右子树必须是黑色，即z必须是z.p的左子树。

	一种情况z本来就是z.p的左子树，另一种情况z是z.p的右子树，那么可以通过左旋就可以实现，然后减交换z和z.p的位置。


总上2点解决方案的分析，我们可以得出如下的分类情况以及解决办法：

-	


