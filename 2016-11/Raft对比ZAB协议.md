# 0 一致性问题

本篇文章想总结下Raft和ZAB在处理一些一致性问题上的做法，详见之前对这2个算法的描述

-	[Raft算法赏析](https://my.oschina.net/pingpangkuangmo/blog/776714)
-	[ZooKeeper的一致性算法赏析](https://my.oschina.net/pingpangkuangmo/blog/778927)

上述分别是针对如下算法实现的讨论：

-	Raft的实现[copycat](https://github.com/atomix/copycat)，由于Raft算法本身已经介绍的相当清晰，copycat基本上和Raft算法保持一致
-	ZAB的实现ZooKeeper，由于ZooKeeper里面的很多实现细节并没有在ZAB里体现（ZAB里面只是一个大概，没有像Raft那么具体），所以这里讨论的都是ZooKeeper的实现

一致性算法在实现状态机这种应用时，有哪些常见的问题：

-	1 leader选举

	-	1.1 一般的leader选举过程

		选举的轮次

		选举出来的leader要包含更多的日志

	-	1.2 leader选举的效率
		
		会不会出现split vote？以及各自的特点是？

	-	1.3 如何加入一个已经完成选举的集群
	
	-	1.4 leader选举的触发

-	2 上一轮次的leader

	-	2.1 上一轮次的leader的残留的数据怎么处理？
	-	2.2 怎么阻止之前的leader假死的问题

-	3 同步过程

	-	3.1 同步一般的流程
	-	3.2 如何保证顺序

		-	3.2.1 正常同步过程的顺序
		-	3.2.2 异常过程的顺序

			follower挂掉又连接

			leader更换

	-	3.3 批量还是单个提交
	-	3.4 同步过程的异常

-	4 日志的持久化和恢复

	-	4.1 状态机数据的快照
	-	4.2 请求的事务记录
	-	4.3 持久化的时机
	-	4.4 如何由状态机数据和事务记录来恢复

-	5 分区的处理

下面分别来看看Raft和ZooKeeper怎么来解决的

# 1 leader选举

为什么要进行leader选举？

在实现一致性的方案，可以像base-paxos那样不需要leader选举，这种方案达成一件事情的一致性还好，面对多件事情的一致性就比较复杂了，所以通过选举出一个leader来简化实现的复杂性。

## 1.1 一般的leader选举过程

更多的有2个要素：

-	1.1.1 选举轮次
-	1.1.2 leader包含更多的日志

1.1.1 选举投票可能会多次轮番上演，为了区分，所以需要定义你的投票是属于哪个轮次的。

-	Raft定义了term来表示选举轮次
-	ZooKeeper定义了electionEpoch来表示

他们都需要在某个轮次内达成过半投票来结束选举过程

1.1.2 投票PK的过程，更多的是日志越新越多者获胜

在选举leader的时候，通常都希望

**选举出来的leader至少包含之前全部已提交的日志**

自然想到包含的日志越新越大那就越好。

通常都是比较最后一个日志记录，如何来定义最后一个日志记录？

有2种选择，一种就是所有日志中的最后一个日志，另一种就是所有已提交中的最后一个日志。目前Raft和ZooKeeper都是采用前一种方式。日志的越新越大表示：轮次新的优先，然后才是统一轮次下日志记录大的优先

-	Raft：term大的优先，然后entry的index大的优先
-	ZooKeeper：peerEpoch大的优先，然后zxid大的优先

	ZooKeeper有2个轮次，一个是选举轮次electionEpoch，另一个是日志的轮次peerEpoch（即表示这个日志是哪个轮次产生的）。而Raft则是只有一个轮次，相当于日志轮次和选举轮次共用了。至于ZooKeeper为什么要把这2个轮次分开，这个稍后再细究，有兴趣的可以一起研究。

但是有一个问题就是：通过上述的日志越新越大的比较方式能达到我们的上述希望吗？

特殊情况下是不能的，这个特殊情况详细见上述给出Raft算法赏析的这一部分

![不能直接提交之前term的entries的案例](https://static.oschina.net/uploads/img/201610/21164723_v2Rh.png "不能直接提交之前term的entries的案例")

这个案例就是这种比较方式会选举出来的leader可能并不包含已经提交的日志，而Raft的做法则是对于日志的提交多加一个限制条件，即不能直接提交之前term的已过半的entry，即把这一部分的日志限制成未提交的日志，从而来实现上述的希望。

ZooKeeper呢？会不会出现这种情况？又是如何处理的？

ZooKeeper是不会出现这种情况的，因为ZooKeeper在每次leader选举完成之后，都会进行数据之间的同步纠正，所以每一个轮次，大家都日志内容都是统一的

而Raft在leader选举完成之后没有这个同步过程，而是靠之后的AppendEntries RPC请求的一致性检查来实现纠正过程，则就会出现上述案例中隔了几个轮次还不统一的现象

## 1.2 leader选举的效率

Raft中的每个server在某个term轮次内只能投一次票，哪个candidate先请求投票谁就可能先获得投票，这样就可能造成split vote，即各个candidate都没有收到过半的投票，Raft通过candidate设置不同的超时时间，来快速解决这个问题，使得先超时的candidate（在其他人还未超时时）优先请求来获得过半投票

ZooKeeper中的每个server，在某个electionEpoch轮次内，可以投多次票，只要遇到更大的票就更新，然后分发新的投票给所有人。这种情况下不存在split vote现象，同时有利于选出含有更新更多的日志的server，但是选举时间相对Raft要花费的多。

## 1.3 如何加入一个已经完成选举的集群



# 2

# 3
