#1 系列目录

-	[分布式事务系列（开篇）提出疑问和研究过程](http://my.oschina.net/pingpangkuangmo/blog/413518)
-	[分布式事务系列（1.1）Spring事务体系的构建]()

#2 jdbc事务

##2.1 例子

	public void save(User user) throws SQLException{
		Connection conn=jdbcDao.getConnection();
		conn.setAutoCommit(false);
		try {
			PreparedStatement ps=conn.prepareStatement("insert into user(name,age) value(?,?)");
			ps.setString(1,user.getName());
			ps.setInt(2,user.getAge());
			ps.execute();
			conn.commit();
		} catch (Exception e) {
			e.printStackTrace();
			conn.rollback();
		}finally{
			conn.close();
		}
	}

##2.2 分析

-	怎么使用事务

	将自动提交设置为false,即conn.setAutoCommit(false)，然后手动来conn.commit()、或者conn.rollback()。

-	一个重要意识

	conn.commit();conn.rollback()等这些属于事务代码，其他执行sql的代码属于业务代码

	只有事务代码和业务代码使用的是同一个Connection的时候，事务的回滚和提交才能正常执行

-	谁在执行事务

	我们可以看到，可以通过操作Connection连接来执行事务，这并不代表Connection具有事务功能，而是使用了数据库自身的事务功能，Connection仅仅是把一些命令如commit、rollback传递给数据库

##2.3 存在的问题

-	1 业务代码都要嵌套在try catch事务模板代码中 
-	2 当存在多个类似save(User user)的业务逻辑时，没法保证他们的原子性

		login(user);
		save(user);

	这两个业务逻辑都是相似的代码,获取Connection连接，然后执行sql语句。没法保证它们的原子性，是因为它们使用的不是同一个连接，不在同一个事务内。

#3 Hibernate的事务

##3.1 例子
	
	public void save(User user){
		Session session=hibernateDao.openSession();
		Transaction tx=null;
		try {
			tx=session.beginTransaction();  
	        session.save(user);  
	        tx.commit();  
		} catch (Exception e) {
			if(tx!=null){
				tx.rollback();
			}
		}finally{
			session.close();
		}
	}

##3.2 分析

-	事务功能和业务功能的分离

	jdbc事务中Connection负担了两方面的功能，事务功能和执行sql的功能。这里的Transaction是Hibernate自己定义的事务，Hibernate则把这两者的功能单独开来，将事务功能交给了Transaction，使得职责更加分工明确。

-	事务的原理

	其实Session、Transaction内部会有一个相同的Connection，这样就保证了 业务代码和事务代码使用的是同一个Connection，Transaction事务的回滚都是依托内部的Connection来完成的，如下：

	-	事务的开始，设置自动提交为false
	
	![事务的开始][1]

	-	事务的提交，通过connection的commit方法来提交

	![事务的提交][2]
		
	事务的回滚等操作，不再列举

#4 Spring事务体系的构建

##4.1 事务功能的总体接口设计

先来看下三大接口

-	PlatformTransactionManager ： 事务管理器

-	TransactionDefinition ： 事务的一些基础信息，如超时时间、隔离级别等

-	TransactionStatus ： 事务及其一些状态信息，如是否是一个新的事务、是否已被标记为回滚

看下PlatformTransactionManager如何来操作事务：

	public interface PlatformTransactionManager {

		//根据事务定义TransactionDefinition，获取事务
		TransactionStatus getTransaction(TransactionDefinition definition);

		//提交事务
		void commit(TransactionStatus status);

		//回滚事务
		void rollback(TransactionStatus status);
	}

##4.2 接口对应的实现

###4.2.1 事务定义接口TransactionDefinition
![事务定义接口][3]

-	红线上方是一些常量定义（事务的隔离级别和事务的传播属性，具体不再说，网上一大堆）
-	事务的定义包含：事务的隔离级别、事务的传播属性、超时时间设置、是否只读

要明白的地方：

事务的隔离级别是数据库本身的事务功能，然而事务的传播属性则是Spring自己为我们提供的功能，数据库事务没有事务的传播属性这一说法。

该接口的实现DefaultTransactionDefinition：默认的事务定义

	public class DefaultTransactionDefinition implements TransactionDefinition, Serializable {
		private int propagationBehavior = PROPAGATION_REQUIRED;
		private int isolationLevel = ISOLATION_DEFAULT;
		private int timeout = TIMEOUT_DEFAULT;
		private boolean readOnly = false;
		//略
	}

-	事务的传播属性为PROPAGATION_REQUIRED，即当前没有事务的时候，创建一个，如果有则使用当前事务
-	事务的隔离级别采用底层数据库默认的隔离级别
-	超时时间采用底层数据库默认的超时时间
-	是否只读为false

###4.2.2 事务接口定义TransactionStatus

先引出Connection中的保存点功能：

	//创建一个保存点
	conn.setSavepoint(name);
	//回滚到某个保存点
	conn.rollback(savepoint);
	//释放某个保存点
	conn.releaseSavepoint(savepoint);

TransactionStatus它继承了SavepointManager接口，SavepointManager是对事务中上述保存点功能的封装，如下：

	public interface SavepointManager {
		Object createSavepoint() throws TransactionException;
		void rollbackToSavepoint(Object savepoint) throws TransactionException;
		void releaseSavepoint(Object savepoint) throws TransactionException;
	}

Spring利用保存点功能实现了事务的嵌套吗？重点去研究下Spring的事务传播属性是咋实现的

TransactionStatus本身更多存储的是事务的一些状态信息：

![事务状态信息][4]

-	是否是一个新的事物
-	是否有保存点
-	是否已被标记为回滚

常用的TransactionStatus接口实现为DefaultTransactionStatus：

![默认的事务定义][5]

目前jdbc事务是通过Connection来实现事务的，Hibernate是通过它自己定义的Transaction来实现的，所以各家的事务都不同，所以Spring只能以Object transaction的形式来表示各家的事务，事务的回滚和提交等操作都会最终委托给上述Object transaction来完成

  
	



##4.1 事务模板代码的抽象和封装




[1]: http://static.oschina.net/uploads/space/2015/0512/075441_9XXX_2287728.png
[2]: http://static.oschina.net/uploads/space/2015/0512/082607_Gwlc_2287728.png
[3]: http://static.oschina.net/uploads/space/2015/0513/071236_2VWv_2287728.png
[4]: http://static.oschina.net/uploads/space/2015/0513/074741_gbXp_2287728.png
[5]: http://static.oschina.net/uploads/space/2015/0513/075126_M5gl_2287728.png

