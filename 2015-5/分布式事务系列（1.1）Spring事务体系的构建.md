#1 系列目录

-	[分布式事务系列（开篇）提出疑问和研究过程]()
-	[分布式事务系列（1.1）Spring事务体系的构建]()

#2 jdbc事务

##2.1 例子

	public void save(User user) throws SQLException{
		Connection conn=jdbcDao.getConnection();
		conn.setAutoCommit(false);
		try {
			PreparedStatement ps=conn.prepareStatement("insert into user(name,age) value(?,?)");
			ps.setString(1,user.getName());
			ps.setInt(2,user.getAge());
			ps.execute();
			conn.commit();
		} catch (Exception e) {
			e.printStackTrace();
			conn.rollback();
		}finally{
			conn.close();
		}
	}

##2.2 分析

-	怎么使用事务

	将自动提交设置为false,即conn.setAutoCommit(false)，然后手动来conn.commit()、或者conn.rollback()。

-	一个重要意识

	conn.commit();conn.rollback()等这些属于事务代码，其他执行sql的代码属于业务代码

	只有事务代码和业务代码使用的是同一个Connection的时候，事务的回滚和提交才能正常执行

-	谁在执行事务

	我们可以看到，可以通过操作Connection连接来执行事务，这并不代表Connection具有事务功能，而是使用了数据库自身的事务功能，Connection仅仅是把一些命令如commit、rollback传递给数据库

##2.3 存在的问题

-	1 业务代码都要嵌套在try catch事务模板代码中 
-	2 当存在多个类似save(User user)的业务逻辑时，没法保证他们的原子性

		login(user);
		save(user);

	这两个业务逻辑都是相似的代码,获取Connection连接，然后执行sql语句。没法保证它们的原子性，是因为它们使用的不是同一个连接，不在同一个事务内。

#3 Hibernate的事务

##3.1 例子
	
	public void save(User user){
		Session session=hibernateDao.openSession();
		Transaction tx=null;
		try {
			tx=session.beginTransaction();  
	        session.save(user);  
	        tx.commit();  
		} catch (Exception e) {
			if(tx!=null){
				tx.rollback();
			}
		}finally{
			session.close();
		}
	}

##3.2 分析

-	事务功能和业务功能的分离

	jdbc事务中Connection负担了两方面的功能，事务功能和执行sql的功能。这里的Transaction是Hibernate自己定义的事务，Hibernate则把这两者的功能单独开来，将事务功能交给了Transaction，使得职责更加分工明确。

-	事务的原理

	其实Session、Transaction内部会有一个相同的Connection，这样就保证了 业务代码和事务代码使用的是同一个Connection，Transaction事务的回滚都是依托内部的Connection来完成的，如下：

	-	事务的开始，设置自动提交为false
	
	![事务的开始][1]

	-	事务的提交

	![事务的提交][2]
		
	事务的回滚等操作，不再列举

#4 Spring事务体系的构建

##4.1 事务模板代码的抽象和封装


[1]: http://static.oschina.net/uploads/space/2015/0512/075441_9XXX_2287728.png
[2]: http://static.oschina.net/uploads/space/2015/0512/082607_Gwlc_2287728.png


