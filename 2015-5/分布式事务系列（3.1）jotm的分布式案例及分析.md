#1 系列目录

-	[分布式事务系列（开篇）提出疑问和研究过程](http://my.oschina.net/pingpangkuangmo/blog/413518)
-	[分布式事务系列（1.1）Spring事务管理器PlatformTransactionManager源码分析](http://my.oschina.net/pingpangkuangmo/blog/415162)
-	[分布式事务系列（1.2）Spring事务体系](http://my.oschina.net/pingpangkuangmo/blog/416038)
-	[分布式事务系列（2.1）分布式事务模型与接口定义](http://my.oschina.net/pingpangkuangmo/blog/417479)

#2 jotm的分布式案例

先来感受下一个分布式事务的案例（使用一般的数据库驱动，不需要支持分布式XA协议）：

##2.1 业务逻辑的操作

UserDao和LogDao,操作分别如下：

	@Repository
	public class UserDao {
	
		@Resource(name="jdbcTemplateA")
		private JdbcTemplate jdbcTemplate;
		
		public void save(User user){
			jdbcTemplate.update("insert into user(name,age) values(?,?)",user.getName(),user.getAge());
		}
	}

	@Repository
	public class LogDao {
	
		@Resource(name="jdbcTemplateB")
		private JdbcTemplate jdbcTemplate;
		
		public void save(User user){
			jdbcTemplate.update("insert into log(name,age) values(?,?)",user.getName(),user.getAge());
		}
	}

即上述两个JdbcTemplate使用不同的数据库。

UserService综合上述两个业务操作，使它们处于同一个事务中：

	@Service
	public class UserService {
		
		@Autowired
		private UserDao userDao;
		@Autowired
		private LogDao logDao;
		
		@Transactional
		public void save(User user){
			userDao.save(user);
			logDao.save(user);
			throw new RuntimeException();
		}
	}

##2.2 配置

上述业务代码我们看不到分布式事务的存在，这种正是我们想要的效果。到底是如何来实现呢？

###2.2.1 dataSource和JdbcTemplate配置

	<!-- 配置数据源 -->
     <bean id="dataSourceA" class="org.enhydra.jdbc.pool.StandardXAPoolDataSource"  destroy-method="shutdown">
     	<property name="dataSource">  
            <bean class="org.enhydra.jdbc.standard.StandardXADataSource" destroy-method="shutdown">  
                <property name="transactionManager" ref="jotm" />  
                <property name="driverName" value="com.mysql.jdbc.Driver" />  
                <property name="url" value="jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8" />  
            </bean>  
        </property>     
        <property name="user" value="root" />  
        <property name="password" value="ligang" />  
    </bean>
 	
 	<!-- 配置数据源 -->
     <bean id="dataSourceB"   class="org.enhydra.jdbc.pool.StandardXAPoolDataSource"  destroy-method="shutdown">   
        <property name="dataSource">  
            <bean class="org.enhydra.jdbc.standard.StandardXADataSource" destroy-method="shutdown">  
                <property name="transactionManager" ref="jotm" />  
                <property name="driverName" value="com.mysql.jdbc.Driver" />  
                <property name="url" value="jdbc:mysql://localhost:3306/test2?useUnicode=true&amp;characterEncoding=utf-8" />  
            </bean>  
        </property>     
        <property name="user" value="root" />  
        <property name="password" value="ligang" /> 
    </bean>

自行配置2个数据库地址

我们平常使用的dataSource，大部分是c3p0、dbcp等，这里就不能使用它们了，需要换成可以模拟XA协议的dataSource，即StandardXAPoolDataSource。这个连接池是xapool的内容。

顺便简单介绍下xapool[官网地址](http://xapool.ow2.org/):

-	它设计了一个GenericPool，这个pool里面可以存放任何Object
-	它设计了一个dataSource即StandardXAPoolDataSource，它可以通过使用普通的数据库驱动来模拟两阶段提交协议中XAResource的作用。本来XAResource是需要由数据库XA驱动来实现的。
-	不过好久都没更新了，官网上最近一次更新还是06年

之后再详细介绍它的源码内容。


###2.2.2 事务配置

我们知道分布式事务中需要一个事务管理器即接口javax.transaction.TransactionManager、面向开发人员的javax.transaction.UserTransaction。对于jotm来说，他们的实现类都是Current，如下源码所示：

	public class Current implements UserTransaction, TransactionManager


我们如果想使用分布式事务的同时，又想使用Spring带给我们的@Transactional便利，就需要配置一个JtaTransactionManager，而该JtaTransactionManager是需要一个userTransaction实例的，所以如下配置：

	<bean id="jotm" class="org.objectweb.jotm.Current" />
    
    <bean id="transactionManager" class="org.springframework.transaction.jta.JtaTransactionManager">  
        <property name="userTransaction" ref="jotm" />  
    </bean>

	<tx:annotation-driven transaction-manager="transactionManager"/>

同时上述StandardXADataSource是需要一个TransactionManager实例的，所以上述StandardXADataSource配置把jotm加了进去

###2.2.3 jar包依赖

整个工程主要是利用jotm和xapool来实现分布式事务。jotm提供事务管理器javax.transaction.TransactionManager和面向开发人员的功能接口javax.transaction.UserTransaction，而xapool则是对非XA数据库驱动进行包装，来模拟XA数据库驱动干的事。所以依赖的pom如下：

	<!-- jotm -->
	<dependency>
		<groupId>org.ow2.jotm</groupId>
		<artifactId>jotm-core</artifactId>
		<version>2.3.1-M1</version>
	</dependency>  
	<dependency>
		<groupId>org.ow2.jotm</groupId>
		<artifactId>jotm-datasource</artifactId>
		<version>2.3.1-M1</version>
	</dependency>
	
	<!-- xapool -->
	<dependency>
		<groupId>com.experlog</groupId>
		<artifactId>xapool</artifactId>
		<version>1.5.0</version>
	</dependency>

上述jotm-datasource主要是为了将上述StandardXAPoolDataSource数据源放置到容器中，如tomcat，而不是应用程序中。应用程序通过JNDI的方式来tomcat容器中获取上述数据源。所以对于本工程来说可以不要


##2.3 分布式事务执行的大致过程

下面先粗略的说明下分布式事务的大致执行过程，即下面的执行过程：

	@Transactional
    public void save(User user){
        userDao.save(user);
        logDao.save(user);
        throw new RuntimeException();
    }

-	第一步：事务拦截器开启事务

	我们知道加入了@Transactional注解，同时开启tx:annotation-driven，会对本对象进行代理，加入事务拦截器。在事务拦截器中，获取javax.transaction.UserTransaction，这里即org.objectweb.jotm.Current，然后使用它开启事务，并和当前线程进行绑定，绑定关系数据存放在org.objectweb.jotm.Current中

-	第二步：使用jdbcTemplate进行业务操作

	jdbcTemplateA要从dataSourceA中获取Connection,和当前线程进行绑定，同时以对应的dataSourceA作为key。同时判断当前线程是否含有事务，通过dataSourceA中的org.objectweb.jotm.Current发现当前线程有事务，则把Connection自动提交设置为false,同时将该连接纳入当前事务中。

	jdbcTemplateB要从dataSourceB中获取Connection,和当前线程进行绑定，同时以对应的dataSourceB作为key。同时判断当前线程是否含有事务，通过dataSourceB中的org.objectweb.jotm.Current发现当前线程有事务，则把Connection自动提交设置为false,同时将该连接纳入当前事务中。

-	第三步：

	一旦抛出异常，则需要进行事务的回滚操作。回滚就是将当前事务进行回滚，该事务的回滚会调用和它关联的所有Connection的回滚。

这里再举一个简单的例子，如下：

	Connection connA=dataSourceA.getConnection();
	Connection connB=dataSourceB.getConnection();
	
	Statement statementA=connA.createStatement();
	Statement statementB=connB.createStatement();
	
	String sql="insert into user(name,age) values('"+user.getName()+"',"+user.getAge()+")";
	
	try {
		connA.setAutoCommit(false);
		connB.setAutoCommit(false);
		
		statementA.execute(sql);
		statementB.execute(sql);
		
		//throw new RuntimeException();

		connA.commit();
		connB.commit();
	} catch (Exception e) {
		e.printStackTrace();
		statementA.close();
		statementB.close();
		connA.rollback();
		connB.rollback();
	}finally{
		connA.close();
		connB.close();
	}

我们这样做：把所有的Connection的自动提交都设置为false,一旦执行过程中发生异常，调用每个Connection的回滚方法，如果没异常，则全部提交。这样做也可以实现分布式事务操作。

而jotm基本也是这样的思路，在上述工程中，使用jdbcTemplate操作，就会把使用的Connection的自动提交设置为false，同时把这个Connection交给事务管理，一旦抛出异常，事务就会把它拥有的所有Connection全部回滚。

2pc体现在哪？



