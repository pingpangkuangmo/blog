#1 java基础：

-	1  算法

	-	1.1 排序算法：直接插入排序、希尔排序、冒泡排序、快速排序、直接选择排序、堆排序、归并排序、基数排序
	-	1.2 二叉查找树、红黑树、B树、B+树

-	2  基本

	-	2.1 字符串常量池的迁移
	-	2.2 字符串KMP算法
	-	2.3 equals和hashcode

-	3  设计模式

	-	单例模式
	-	工厂模式
	-	装饰者模式
	-	观察者设计模式
	-	ThreadLocal设计模式

-	3  线程池源码

-	4  正则表达式
	
	-	4.1 捕获组和非捕获组
	-	4.2 贪婪，勉强，独占模式

-	5  java内存模型以及垃圾回收算法

	-	5.1 类加载器，以及J2EE的类加载器案例
	-	5.2 java内存分配模型（默认HotSpot）
		
		线程共享的：堆区、永久区
		线程独享的：虚拟机栈、本地方法栈、程序计数器
	-	5.3 内存分配机制：年轻代（Eden区、两个Survivor区）、年老代、永久代以及他们的分配过程
	-	5.4 年轻代：停止-复制算法；年老代：标记-整理算法
	-	5.5 常用垃圾收集器算法：
	
		新生代：Serial收集器、ParNew收集器、Parallel Scavenge 收集器
		
		老年代：Serial Old收集器、Parallel Old收集器、CMS（Concurrent Mark Sweep）收集器、 G1 收集器
	-	5.6 常用gc的参数：-Xmn、-Xms、-Xmx、-XX:MaxPermSize、-XX:SurvivorRatio、-XX:-PrintGC Details
	-	5.7 常用工具： jps、jstat、jmap、jstack、图形工具jConsole、Visual VM、MAT

-	6  锁以及并发容器的源码

	-	6.1 synchronized和volatile理解
	-	6.2 Unsafe类的原理，使用它来实现CAS。因此诞生了AtomicInteger系列等
	-	6.3 CAS可能产生的ABA问题的解决，如加入修改次数、版本号
	-	6.4 同步器AQS的实现原理
	-	6.5 独占锁、共享锁；可重入的独占锁ReentrantLock、共享锁 实现原理
	-	6.6 公平锁和非公平锁
	-	6.7 读写锁 ReentrantReadWriteLock的实现原理
	-	6.8 LockSupport工具
	-	6.9 Condition接口及其实现原理
	-	6.10 HashMap、HashTable、ConcurrentHashMap的实现原理
	-	6.11 ConcurrentLinkedQueue的实现原理
	-	6.12 Fork/Join框架

#2 web方面：

-	1  SpringMVC的架构设计

	-	1.1 servlet开发存在的问题：映射问题、参数获取问题、格式化转换问题、返回值处理问题、视图渲染问题
	-	1.2 SpringMVC为解决上述问题开发的几大组件及接口：HandlerMapping、HandlerAdapter、HandlerMethodArgumentResolver、HttpMessageConverter、Converter、GenericConverter、HandlerMethodReturnValueHandler、ViewResolver、MultipartResolver
	-	1.3 DispatcherServlet、容器、组件三者之间的关系
	-	1.4 叙述SpringMVC对请求的整体处理流程
	-	1.5 SpringBoot

-	2  SpringAOP源码

	-	2.1 AOP的实现分类：编译期、字节码加载前、字节码加载后三种时机来实现AOP
	-	2.2 深刻理解其中的角色：AOP联盟、aspectj、jboss AOP、Spring自身实现的AOP、Spring嵌入aspectj。特别是能用代码区分后两者
	-	2.3 接口设计：
		
		AOP联盟定义的概念或接口：Pointcut（概念，没有定义对应的接口）、Joinpoint、Advice、MethodInterceptor、MethodInvocation
		
		SpringAOP针对上述Advice接口定义的接口及其实现类：BeforeAdvice、AfterAdvice、MethodBeforeAdvice、AfterReturningAdvice；针对aspectj对上述接口的实现AspectJMethodBeforeAdvice、AspectJAfterReturningAdvice、AspectJAfterThrowingAdvice、AspectJAfterAdvice。
	
		SpringAOP定义的定义的AdvisorAdapter接口：将上述Advise转化为MethodInterceptor

		SpringAOP定义的Pointcut接口：含有两个属性ClassFilter（过滤类）、MethodMatcher（过滤方法）

		SpringAOP定义的ExpressionPointcut接口：实现中会引入aspectj的pointcut表达式

		SpringAOP定义的PointcutAdvisor接口（将上述Advice接口和Pointcut接口结合起来）

	-	2.4 SpringAOP的调用流程

	-	2.5 SpringAOP自己的实现方式（代表人物ProxyFactoryBean）和借助aspectj实现方式区分

-	3  Spring事务体系源码以及分布式事务Jotm Atomikos源码实现

	-	3.1 jdbc事务存在的问题
	-	3.2 Hibernate对事务的改进
	-	3.3 针对各种各样的事务，Spring如何定义事务体系的接口，以及如何融合jdbc事务和Hibernate事务的
	-	3.4 三种事务模型包含的角色以及各自的职责
	-	3.5 事务代码也业务代码分离的实现（AOP+ThreadLocal来实现）
	-	3.6 Spring事务拦截器TransactionInterceptor全景
	-	3.7 X/Open DTP模型，两阶段提交，JTA接口定义
	-	3.8 Jotm、Atomikos的实现原理

-	4  数据库隔离级别

	-	4.1 Read uncommitted：读未提交
	-	4.2 Read committed ： 读已提交
	-	4.3 Repeatable read：可重复读
	-	4.4 Serializable ：串行化


-	5 sql中死锁

	-	5.1 深入理解Record Locks、Gap Locks、Next-Key Locks

	例如：

		start transaction;
		DELETE FROM t WHERE id =6;
		INSERT INTO t VALUES(6);
		commit;

-	6 ORM框架: mybatis、Hibernate
	
#3 分布式、java中间件、web服务器等方面：

-	1  ZooKeeper源码

	-	1.1 客户端架构
	-	1.2 服务器端单机版和集群版，对应的请求处理器
	-	1.3 集群版session的建立和激活过程
	-	1.4 Leader选举过程
	-	1.5 事务日志和快照文件的详细解析

-	2  序列化和反序列化框架Avro、Thrift、Protobuf、Protostuff

	-	2.1 Avro研究
	-	2.2 Thrift研究
	-	2.3 Protobuf研究
	-	2.4 Protostuff研究

-	3  dubbo源码

	-	3.1 dubbo扩展机制的实现
	-	3.2 服务的发布过程
	-	3.3 服务的订阅过程
	-	3.4 RPC通信的设计

-	4  NIO模块以及对应的Netty和Mina、thrift源码

	-	4.1 TCP握手和断开
	-	4.2 backlog
	-	4.3 BIO NIO
	-	4.4 Reactor线程模型

	![输入图片说明](https://static.oschina.net/uploads/img/201510/20083738_I5mX.png "在这里输入图片标题")
	
	![输入图片说明](https://static.oschina.net/uploads/img/201510/31082759_7QTr.png "在这里输入图片标题")

	![输入图片说明](https://static.oschina.net/uploads/img/201510/20083315_ObVg.png "在这里输入图片标题")

-	5  消息队列kafka、MetaQ、Notify

	-	5.1 kafka的文件存储设计
	-	5.2 kafka的高可用设计
	-	5.3 kafka的局限性，很多高级特性没有：事物、事后重试，更重要的是服务治理不健全，一旦出问题，不能直观反应出来
	-	5.4 Notify的事务设计

-	6  数据库的分库分表mycat

-	7  NoSql数据库mongodb

-	8  分布式缓存 memcached redis

-	9  web服务器tomcat、ngnix的设计原理

	-	9.1 tomcat的整体架构设计
	-	9.2 tomcat对通信的并发控制
	-	9.2 http请求到达tomcat的整个处理流程

-	10 ELK日志实时处理查询系统

	Elasticsearch、Logstash、Kibana

-	11 扩展

	-	11.1 SOA
	
	![输入图片说明](https://static.oschina.net/uploads/img/201607/25124745_Bo1o.png "在这里输入图片标题")

	-	11.2 服务的合并部署、多版本部署
	
	![输入图片说明](https://static.oschina.net/uploads/img/201607/25123602_ooBv.png "在这里输入图片标题")

	-	11.3 服务的治理：限流、降级
	
		服务限流：令牌桶、漏桶
		
		![输入图片说明](https://static.oschina.net/uploads/img/201607/25125029_2RMr.png "在这里输入图片标题")

		![输入图片说明](https://static.oschina.net/uploads/img/201607/25125120_4Cy4.png "在这里输入图片标题")

		服务降级：netflix的hystrix组件

	-	11.4 服务的线性扩展

		无状态的服务如何做线性扩展：
		
			如一般的web应用，直接使用DNS做负载均衡
			如RPC应用，需要借助于zookeeper等做负载均衡
		
		有状态服务如何做线性扩展：
		
			如Redis的扩展：一致性hash，迁移工具

	-	11.5 服务的链路监控：CAT
		

# 4 大数据方向

-	1 MapReduce

	-	1.1 MapReduce理论体系
-	2 HDFS

	-	2.1 如何实现一致性

-	3 YARN、Mesos 资源调度

-	4 Hive

	-	4.1 HiveServer2的thrift RPC通信过程
	-	4.2 Hive的优化过程
-	5 Hbase

	-	5.1 Hbase的整体架构图
	-	5.2 Hbase的WAL和MVCC设计

-	6 Spark
