#1 java基础：

-	1  算法

	-	1.1 排序算法：直接插入排序、希尔排序、冒泡排序、快速排序、直接选择排序、堆排序、归并排序、基数排序
	-	1.2 哈夫曼树、斐波那契数列、红黑树

-	2  String字符串

	-	2.1 字符串常量池的迁移
	-	2.2 

-	3  设计模式

	-	单例模式
	-	工厂模式
	-	装饰者模式
	-	观察者设计模式
	-	ThreadLocal设计模式

-	3  线程池源码

-	4  正则表达式
	
	-	4.1 捕获组和非捕获组
	-	4.2 贪婪，勉强，独占模式

-	5  java内存模型以及垃圾回收算法

	-	5.1 类加载器，以及J2EE的类加载器案例
	-	5.2 java内存分配模型（默认HotSpot）
		
		线程共享的：堆区、永久区
		线程独享的：虚拟机栈、本地方法栈、程序计数器
	-	5.3 内存分配机制：年轻代（Eden区、两个Survivor区）、年老代、永久代以及他们的分配过程
	-	5.4 年轻代：停止-复制算法；年老代：标记-整理算法
	-	5.5 常用垃圾收集器算法：
	
		新生代：Serial收集器、ParNew收集器、Parallel Scavenge 收集器
		
		老年代：Serial Old收集器、Parallel Old收集器、CMS（Concurrent Mark Sweep）收集器、 G1 收集器
	-	5.6 常用gc的参数：-Xmn、-Xms、-Xmx、-XX:MaxPermSize、-XX:SurvivorRatio、-XX:-PrintGC Details
	-	5.7 常用工具： jps、jstat、jmap、jstack、图形工具jConsole、Visual VM、MAT

-	6  锁以及并发容器的源码

	-	6.1 synchronized和volatile理解
	-	6.2 Unsafe类的原理，使用它来实现CAS。因此诞生了AtomicInteger系列等
	-	6.3 CAS可能产生的ABA问题的解决，如加入修改次数、版本号
	-	6.4 同步器的实现原理
	-	6.5 独占锁、共享锁；可重入的独占锁ReentrantLock、共享锁 实现原理
	-	6.6 读写锁 ReentrantReadWriteLock的实现原理
	-	6.7 LockSupport工具
	-	6.8 Condition接口及其实现原理
	-	6.9 HashMap、HashTable、ConcurrentHashMap的实现原理
	-	6.10 ConcurrentLinkedQueue的实现原理
	-	6.11 Fork/Join框架

#2 web方面：

-	1  SpringMVC的架构设计

	-	1.1 servlet开发存在的问题：映射问题、参数获取问题、格式化转换问题、返回值处理问题、视图渲染问题
	-	1.2 SpringMVC为解决上述问题开发的几大组件及接口：HandlerMapping、HandlerAdapter、HandlerMethodArgumentResolver、HttpMessageConverter、Converter、GenericConverter、HandlerMethodReturnValueHandler、ViewResolver、MultipartResolver
	-	1.3 DispatcherServlet、容器、组件三者之间的关系
	-	1.4 叙述SpringMVC对请求的整体处理流程

-	2  SpringAOP源码

	-	2.1 AOP的实现分类：编译期、字节码加载前、字节码加载后三种时机来实现AOP
	-	2.2 深刻理解其中的角色：AOP联盟、aspectj、jboss AOP、Spring自身实现的AOP、Spring嵌入aspectj。特别是能用代码区分后两者
	-	2.3 接口设计：
		
		AOP联盟定义的概念或接口：Pointcut（概念，没有定义对应的接口）、Joinpoint、Advice、MethodInterceptor、MethodInvocation
		
		SpringAOP针对上述Advice接口定义的接口及其实现类：BeforeAdvice、AfterAdvice、MethodBeforeAdvice、AfterReturningAdvice；针对aspectj对上述接口的实现AspectJMethodBeforeAdvice、AspectJAfterReturningAdvice、AspectJAfterThrowingAdvice、AspectJAfterAdvice。
	
		SpringAOP定义的定义的AdvisorAdapter接口：将上述Advise转化为MethodInterceptor

		SpringAOP定义的Pointcut接口：含有两个属性ClassFilter（过滤类）、MethodMatcher（过滤方法）

		SpringAOP定义的ExpressionPointcut接口：实现中会引入aspectj的pointcut表达式

		SpringAOP定义的PointcutAdvisor接口（将上述Advice接口和Pointcut接口结合起来）

	-	2.4 SpringAOP的调用流程

	-	2.5 SpringAOP自己的实现方式（代表人物ProxyFactoryBean）和借助aspectj实现方式区分

-	3  Spring事务体系源码以及分布式事务Jotm Atomikos源码实现

	-	3.1 jdbc事务存在的问题
	-	3.2 Hibernate对事务的改进
	-	3.3 针对各种各样的事务，Spring如何定义事务体系的接口，以及如何融合jdbc事务和Hibernate事务的
	-	3.4 三种事务模型包含的角色以及各自的职责
	-	3.5 事务代码也业务代码分离的实现（AOP+ThreadLocal来实现）
	-	3.6 Spring事务拦截器TransactionInterceptor全景
	-	3.7 X/Open DTP模型，两阶段提交，JTA接口定义
	-	3.8 Jotm、Atomikos的实现原理

-	4  sql语法

	-	4.1 一些sql面试题

-	5  数据库隔离级别

	-	5.1 Read uncommitted：读未提交
	-	5.2 Read committed ： 读已提交
	-	5.3 Repeatable read：可重复读
	-	5.4 Serializable ：串行化


#3 分布式、java中间件、web服务器等方面：

-	1  ZooKeeper源码

	-	1.1 客户端架构
	-	1.2 服务器端单机版和集群版，对应的请求处理器
	-	1.3 集群版session的建立和激活过程
	-	1.4 Leader选举过程
	-	1.5 事务日志和快照文件的详细解析

-	2  序列化和反序列化框架Avro、Thrift、Protobuf、Protostuff

	-	2.1 Avro研究
	-	2.2 Thrift研究
	-	2.3 Protobuf研究
	-	2.4 Protostuff研究

-	3  dubbo源码

-	4  NIO模块以及对应的Netty和Mina源码

-	5  消息队列kafka MetaQ

-	6  数据库的分库分表mycat

-	7  NoSql数据库mongodb

-	8  分布式缓存 memcached redis

-	9  web服务器tomcat、ngnix的设计原理

	-	9.1 http请求到达tomcat的整个处理流程


#4 自己的项目

-	1 cmsSearch的整体架构

	-	1.1 需求分析
	-	1.2 设计思路
