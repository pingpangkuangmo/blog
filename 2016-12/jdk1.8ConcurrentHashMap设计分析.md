本文针对jdk1.8的ConcurrentHashMap

# 1 1.8的HashMap设计

## 1.1 整体概览

HashMap采用的是**数组+链表+红黑树**的形式。

数组是可以扩容的，链表也是转化为红黑树的，这2种方式都可以承载更多的数据。

初始总容量，默认16，默认的加载因子0.75

容量X加载因子=阈值

一旦目前容量超过该阈值，则执行扩容操作。

什么时候扩容？

-	1 当前容量超过阈值
-	2 当链表中元素个数超过默认设定（8个），当数组的大小还未超过64的时候，此时进行数组的扩容，如果超过则将链表转化成红黑树

什么时候链表转化为红黑树？（上面已经提到了）

-	当数组大小已经超过64并且链表中的元素个数超过默认设定（8个）时，将链表转化为红黑树


目前形象的表示数组中的一个元素称为一个桶

## 1.2 put过程

-	根据key计算出hash值
-	hash值&（数组长度-1）得到所在数组的index
	-	如果该index位置的Node元素不存在，则直接创建一个新的Node
	-	如果该index位置的Node元素是TreeNode类型即红黑树类型了，则直接按照红黑树的插入方式进行插入
	-	如果该index位置的Node元素是非TreeNode类型则，则按照链表的形式进行插入操作

		链表插入操作完成后，判断是否超过阈值TREEIFY_THRESHOLD（默认是8），超过则要么数组扩容要么链表转化成红黑树
-	判断当前总容量是否超出阈值，如果超出则执行扩容

源码如下：

![HashMap的put过程](https://static.oschina.net/uploads/img/201612/28154542_9bV6.png "HashMap的put过程")

下面来说说这个扩容的过程

## 1.3 扩容过程

按照2倍扩容的方式，那么就需要将之前的所有元素全部重新按照2倍桶的长度重新计算所在桶。这里为啥是2倍？

因为2倍的话，更加容易计算他们所在的桶，并且各自不会相互干扰。如原桶长度是4，现在桶长度是8，那么

-	桶0中的元素会被分到桶0和桶4中
-	桶1中的元素会被分到桶1和桶5中
-	桶2中的元素会被分到桶2和桶6中
-	桶3中的元素会被分到桶3和桶7中

为啥是这样呢？

桶0中的元素的hash值后2位必然是00，这些hash值可以根据后3位000或者100分成2类数据。他们分别&（8-1）即&111,则后3位为000的在桶0中，后3位为100的必然在桶4中。其他同理，也就是说桶4和桶0重新瓜分了原来桶0中的元素。

如果换成其他倍数，那么瓜分就比较混乱了。

这样在瓜分这些数据的时候，只需要先把这些数据分类，如上述桶0中分成000和1002类，然后直接构成新的链表，分类完毕后，直接将新的链表挂在对应的桶下即可，源码如下：

![HashMap的扩容过程](https://static.oschina.net/uploads/img/201612/28161812_Tk31.png "HashMap的扩容过程")

上述 (e.hash & oldCap) == 0 即可将原桶中的数据分成2类

上述是对于链表情况下的重新移动，而针对红黑树情况下：

则需要考虑分类之后是否还需要依然保持红黑树，如果个数少则直接使用链表即可。

## 1.4 get过程

get过程比较简单

-	根据key计算出hash值
-	hash值&（数组长度-1）得到所在数组的index

	-	如果要找的key就是上述数组index位置的元素，直接返回该元素的值
	-	如果该数组index位置元素是TreeNode类型，则按照红黑树的查询方式来进行查找
	-	如果该数组index位置元素非TreeNode类型，则按照链表的方式来进行遍历查询

源码如下：

![HashMap的get过程](https://static.oschina.net/uploads/img/201612/28165110_Qgbu.png "HashMap的get过程")

# 2 1.7的ConcurrentHashMap设计

ConcurrentHashMap是线程安全，通过分段锁的方式提高了并发度。分段是一开始就确定的了，后期不能再进行扩容的。

其中的段Segment继承了重入锁ReentrantLock，有了锁的功能，同时含有类似HashMap中的数组加链表结构



## 1.1 整体概览

## 1.2 初始化过程

## 1.2 put过程

## 1.3 get过程

## 1.4 扩容过程


# 3 1.8的ConcurrentHashMap设计

ConcurrentHashMap是线程安全，通过分段锁的方式提高了并发度。

## 3.1 整体概览

## 3.2 初始化过程

## 3.2 put过程

## 3.3 get过程

## 3.4 扩容过程

# 4 问题分析

## 4.1 ConcurrentHashMap读为什么不需要锁？


## 4.2 